 <mark style="background: #FFF3A3A6;">Что такое индексы, каких бывают?(кластеризованные и некластеризованные)?</mark>
	**Индекс** - специальный объект БД, который предназначен для повышения производительности поиска данных, являются вспомогательными структурами - можно удалить и восстановить по информации в таблице. Кроме того, служат для поддержки ограничений целостности.
	Индексы бывают *кластеризованные и некластеризованные*
		<mark style="background: #FFB8EBA6;">Кластеризованные</mark> - индексы, сортирующие строки с данными в таблице. Хранят данные в листьях индекса. Всегда отсортированы либо по возрастанию, либо по убыванию. Данные упорядочены физически (на носителе - SSD, HDD) => ускоряется поиск по БД. Но из за этого при изменении порядка данных может затрачиваться много ресурсов и придётся перестраивать таблицу. Создаётся сразу на всю таблицу. В таблице может быть только 1 кластеризованный индекс				<mark style="background: #FFB8EBA6;">Некластеризованные</mark> - индексы, применяющиеся к неключевым столбцам. Не упорядочивают физически. Хранит данные и индексы в разных местах. Сам по себе содержит указатели на записи в таблице. Можно иметь больше 1 индекса в таблице. Занимает мало места на диске, но более медленный чем кластеризованный индекс. Применяется только к тем столбцам, которые используются в запросах с соединениями (join)
		
 <mark style="background: #FFF3A3A6;">Для чего нужны индексы, как использовать </mark>
	 Индексы нужны для ускорения процесса поиска по таблице. 
	 Как использовать:
	 Создаём таблицу
```postgresql
CREATE TABLE movies (
	id SERIAL PRIMARY KEY,     
	title TEXT NOT NULL );
```
Создаём индекс для столбца id
```postgresql
CREATE INDEX cluster_id ON movies (id);
```
Теперь создаём кластерный индекс
```postgresql
CLUSTER movies USING cluster_id;
```
Так было достигнуто ускорение при выполнении запросов.
Для некластеризованного:
```postgresql
CREATE INDEX non_clustered_index ON movies (title);
```


<mark style="background: #FFF3A3A6;">Составной индекс, как это работает?</mark>
**Составной индекс** - индекс, создаваемый по нескольким столбцам. Для создания:
```postgresql
CREATE INDEX non_clustered_index ON movies (title,genre);
```
*В отличие от "одинарного" индекса в качестве индексируемого значения использует не одно значение, а несколько значений* 
То есть, если есть 2 поля A и B, то составной индекс по ним будет выглядеть примерно так:
```
| A | B | 
---------
| 1 | 1 | 
| 1 | 2 | 
| 1 | 4 | 
| 2 | 2 | 
| 2 | 3 | 
| 2 | 5 |
```
Грубо говоря это сортировка по двум полям, а не одному полю. То есть это не индексирование конкатенированных значений A+B.
A - дерево 1
B - дерево 2
Листья A являются ссылками на дерево B, т.е. вложенными
<mark style="background: #FFF3A3A6;">Типы индексов в postgreSQL(основные)? достаточно названий(b-tree,hash,gist). Посмотреть в чем их разница между собой и понимать какой индекс что делает.</mark>
Типы индексов:
1) B-дерево
   Структура данных, представляющее собой сбалансированное (длина любого пути от корня до листьев различается не более чем на 1 (глубина ветвей различается не более чем на 1)) и ветвистое (каждый узел ссылается на большое количество потомков) дерево
   С точки зрения физической организации B-дерево представляется как мультисписочная структура страниц памяти, то есть каждому узлу дерева соответствует блок памяти (страница). Внутренние и листовые страницы обычно имеют разную структуру.
2) Hash-индекс
   Использует хэш-таблицу. Принимает значение, вычисляет хэш-функцией для него ключ, и кладёт в соответствующее ведро. Могут быть коллизии (для разных ключей одно и тоже значение), с ними борются линейное зондирование и метод цепочек
3) GiST (Generalized Search Tree)
   Структура индекса, обобщенная разновидность R-дерева. Представляет собой сбалансированное дерево, листья которого содержат пары (ключ, rid), где rid - указатель на соответствующую запись на странице данных. Внутренние узлы содержат пары (p, ptr), где p - предикат (ключ), ptr - указатель на узел. Определены базовые методы, SEARCH, INSERT, DELETE
4) SP-GiST - Space Partitioning GiST
   Тот же GiST, но рекурсивно разбивает непересекающиеся пространства (квадранты)
5) GIN - Generalized Inverted Index - работает с типами данных, не являющимися атомарными. Является инвертированным индексом, т.е. содержит записи для всех слов со списком мест их вхождения
6) BRIN - Block Range Index (индекс зон блоков) - BRIN предназначается для обработки очень больших таблиц, в которых определённые столбцы некоторым естественным образом коррелируют с их физическим расположением в таблице. _Зоной блоков_ называется группа страниц, физически расположенных в таблице рядом; для каждой зоны в индексе сохраняется некоторая сводная информация. Например, в таблице заказов магазина может содержаться поле с датой добавления заказа, и практически всегда записи более ранних заказов и в таблице будут размещены ближе к началу; в таблице, содержащей столбец с почтовым индексом, также естественным образом могут группироваться записи по городам.
   

 <mark style="background: #FFF3A3A6;">Что такое журнал предзаписи в postgreSQL и как используется?</mark>
	 Журнал предзаписи (Write Ahead Log) - стандартный метод обеспечения целостности данных. Представляет собой лог, который делает запись об изменениях в БД на физическом носителе ещё ДО того, как туда попадёт измененная страница, для того, чтобы не было ситуации, когда БД была изменена, а записи в журнале не осталось. Запись в журнале представляет из себя минимальную информацию, достаточную для того, чтобы при необходимости изменение можно было повторить.
	 Плюсы по сравнению с записью самих страниц с данными:
	 1) Является последовательным потоком данных на запись => выполняется эффективнее чем запись самих данных
	 2) Меньше, чем сама страница данных
	 3) Не приходится заботиться о согласованности данных
	 4) Логами можно восстанавливать, копировать и реплицировать данные
	Журналировать нужно все операции, при выполнении которых есть риск получить несогласованность на диске в случае сбоя. В частности, в журнал записываются следующие действия:
	- изменение страниц в буферном кеше (как правило, это страницы таблиц и индексов),  так как измененная страница попадает на диск не сразу;
	- фиксация и отмена транзакций — изменение статуса происходит в буферах XACT и тоже попадает на диск не сразу;
	- файловые операции (создание и удаление файлов и каталогов, например, создание файлов при создании таблицы) — так как эти операции должны происходить синхронно с изменением данных.
	Посмотреть логи можно утилитой pg_waldump
	Восстановление происходит при запуске БД. Если до запуска было состояние shut down, то восстановление не требуется. Если СУБД упала, но статус in production - будет запущено восстановление
	  
<mark style="background: #FFF3A3A6;">Репликация базы данных, что это и как работает?</mark>
Репликация - дублирование БД, когда данные с одного сервера полностью повторяются на других. Нужно для повышения отказоустойчивости (1 сервер падает, остальные работают) и производительности (распределение данных по серверам в разных локациях повышает скорость доступа данных для пользователей)
Есть несколько видов репликации: 
 - Потоковая - от основного сервера на реплики передаётся журнал предзаписи, и каждый сервер воссоздает данные по журналу. Для настройки такой репликации все серверы должны быть одной версии, работать на одной ОС и архитектуре.
   Потоковая в свою очередь делится на 2 вида: синхронная и асинхронная
	   1) Синхронная - в случае изменения сначала передаётся WAL на реплику и только после этого всё фиксируется на основном сервере, является более надёжным, но медленным способом
	   2) Асинхронная - сначала данные изменяются на основном сервере, и только после этого отправляют WAL на реплики. Преимущество - быстрое подтверждение транзакции, недостаток - ненадёжно, т.к. основной сервер может упасть, но данные могут не передаться => нарушение целостности данных на репликах
- Логическая - оперирует записями в таблицах PostgreSQL. Этот вид построен на механизме публикации/подписки - один сервер публикует их, другой подписывается. При этом можно подписаться не на все изменения. При этом нельзя реплицировать изменения структуры БД (Если добавится таблица или столбец, то эти изменения автоматически не попадут в реплики, нужно добавлять их вручную). Может работать с разными архитектурами и версиями.
<mark style="background: #FFF3A3A6;">Что такое ACID?</mark>
ACID - набор требований к транзакционной системе для обеспечения сохранности данных.
Расшифровка:
Atomicity (Атомарность) - каждая транзакция либо выполнится полностью, либо не выполнится совсем
Consistency (Согласованность) - каждая транзакция должна быть согласованной (т.е. выполняться ТОЛЬКО полностью и фиксирующая допустимые результаты)
Isolation (Изолированность) - во время выполнения транзакции параллельные ей транзакции не должны иметь влияния на результат
Durability (Надёжность) - Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.

<mark style="background: #FFF3A3A6;">Уровень изоляций транзакций, какие есть, в чем их особенность?</mark>
Проблемы с параллельными транзакциями (описанные в PostgreSQL):
1) Потерянное обновление - Есть 500 рублей. Юзер1 открыл транзакцию, снял с них 300 (500-300=200), после этого Юзер2 положил на них 300, но Юзер1 не закрыл ещё свою транзакцию, поэтому Юзер2 всё ещё видит 500 рублей. Юзер1 закрыл свою транзакцию, в итоге получилось 200 рублей. После этого Юзер2 закрывают свою транзакцию, получает 500+300=800 рублей. Действия Юзера1 не сохранились (кто последний закрыл транзакцию - те изменения и зафиксируются)
2) Грязное чтение
   Транзакция читает данные, записанные параллельной незавершённой транзакцией
    Есть 500 рублей. Юзер1 снял 300 (500-300=200. Юзер2 вытянул данные о деньгах (200 рублей). После этого Юзер1 сделал откат (снова 500 рублей). Юзер2 получил неправильную информацию. 
3) Неповторяющееся чтение
   Юзер1 делает отчёт. Операции идут последовательно на протяжении отрезка времени. Во время этого отрезка Юзер2 <mark style="background: #FFB86CA6;">изменяет</mark> данные в БД. Юзер1 получает отчёт на основании 2 разных данных.
4) Фантомное чтение
   Юзер1 делает отчёт. Операции идут последовательно на протяжении отрезка времени. Во время этого отрезка Юзер2 <mark style="background: #FFB86CA6;">добавляет/удаляет</mark> данные в БД. Юзер1 получает отчёт на основании 2 разных данных.
   С этими проблемами помогают справиться изоляция. Всего у изоляции 2 уровня:
   1) <mark style="background: #FF5582A6;">Read Uncommited.</mark> Низший уровень изоляции. 
      Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определённое всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.
      Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполняются последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются. 
   2) <mark style="background: #FF5582A6;">Read Commited.</mark> Является уровнем изоляции по умолчанию.
      Такой уровень изоляции всегда позволяет видеть изменения внесённые успешно завершёнными транзакциями в оставшихся параллельно открытых транзакциях. В транзакции, работающей на этом уровне, запрос SELECT (без предложения FOR UPDATE/SHARE) видит только те данные, которые были зафиксированы до начала запроса; он никогда не увидит незафиксированных данных или изменений, внесённых в процессе выполнения запроса параллельными транзакциями. По сути запрос SELECT видит снимок базы данных в момент начала выполнения запроса. Однако SELECT видит результаты изменений, внесённых ранее в этой же транзакции, даже если они ещё не зафиксированы. Также заметьте, что два последовательных оператора SELECT могут видеть разные данные даже в рамках одной транзакции, если какие-то другие транзакции зафиксируют изменения после выполнения первого SELECT.
  3) <mark style="background: #FF5582A6;">Repeatable Read.</mark>
     Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.
     Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции. При повторном запуске инструкции текущей транзакцией будут извлечены новые строки, что приведёт к фантомному чтению. Учитывая то, что разделяющие блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой инструкции, степень параллелизма ниже, чем при уровне изоляции READ COMMITTED. Поэтому пользоваться данным и более высокими уровнями изоляции транзакций без необходимости обычно не рекомендуется.
  4) <mark style="background: #FF5582A6;">Serializable.</mark>
	   Изоляция уровня Serializable обеспечивает беспрепятственный доступ к базе данных транзакциям с SELECT запросами. Но для транзакций с запросами UPDATE и DELETE, уровень изоляции Serializable не допускает модификации одной и той же строки в рамках разных транзакций. При изоляции такого уровня все транзакции обрабатываются так, как будто они все запущены последовательно (одна за другой). Если две одновременные транзакции попытаются обновить одну и туже строку, то это будет не возможно. В таком случае PostgreSQL принудит транзакцию, вторую, да и все последующие, что пытались изменить строку к отмене (откату — ROLLBACK).
	   

| Уровень изоляции | Фантомное чтение | Неповторяющееся чтение | Грязное чтение    | Потерянное обновление         |
| ---------------- | ---------------- | ---------------------- | ----------------- | ----------------------------- |
| Read Uncommited  | Не предотвращает | Не предотвращает       | Не предотвращает  | Предотвращает                 |
| Read Commited    | Не предотвращает | Не предотвращает       | Предотвращает     | Предотвращает<br>(блокировка) |
| Repeatable Read  | Не предотвращает | Предотвращает          | Предотвращает     | Предотвращает                 |
| Serializable     | Предотвращает    | Предотвращает<br>      | Предотвращает<br> | Предотвращает<br>             |

 <mark style="background: #FFF3A3A6;">Виды join*ов и их различия?</mark>
 JOIN — это один из ключевых операторов SQL, который позволяет объединять данные из разных таблиц.
 Виды:
 1) Внутренний (INNER)
    INNER JOIN возвращает только те строки, которые имеют соответствующие значения в обеих таблицах.
    Пример:
    ```postgresql
    SELECT a.*, b.* FROM table1 a
    INNER JOIN table2 b ON a.common_field = b.common_field;
    	```
  2) Внешний
    <mark style="background: #BBFABBA6;">LEFT JOIN</mark>
         Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если в правой таблице нет соответствующих строк, результат будет содержать NULL для столбцов из правой таблицы.
```postgresql
         SELECT a.*, b.* FROM table1 a
         LEFT JOIN table2 b ON a.common_field = b.common_field;
         ```
         
<mark style="background: #BBFABBA6;">RIGHT JOIN</mark>
		RIGHT JOIN возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если в левой таблице нет соответствующих строк, результат будет содержать NULL для столбцов из левой таблицы.
```postgresql
         SELECT a.*, b.* FROM table1 a
         RIGHT JOIN table2 b ON a.common_field = b.common_field;
         ```
    
<mark style="background: #BBFABBA6;">FULL JOIN</mark>
		Возвращает все строки из двух таблиц
```postgresql
         SELECT a.*, b.* FROM table1 a
         FULL JOIN table2 b ON a.common_field = b.common_field;
         ```
![[PostgreSQL-Joins.png]]
  <mark style="background: #BBFABBA6;">CROSS JOIN</mark>
	  Возвращает декартово произведение двух таблиц (<mark style="background: #FF5582A6;">все возможные перестановки</mark>)
	  ![[sql-cross-join-working-principle.png]]
```postgresql
         SELECT a.*, b.* FROM table1 a
         CROSS JOIN table2;
         ```
<mark style="background: #BBFABBA6;">SELF JOIN</mark>
Соединение таблицы с самой собой. Нужно для работы с иерархическими данными или сравнения строк внутри таблицы

  <mark style="background: #FFF3A3A6;">Виды блокировок?(оптимистичная и песиместичная)?</mark>
	  Оптимистическая блокировка - неблокирующий метод контроля параллелизма, состоящий из 4 фаз:
	  1) Начало - фиксируем временную метку начала транзакции
	  2) Изменение данных - чтение, запись
	  3) Валидация - проверяем, изменились ли данные извне в ходе нашей транзакции
	  4) Коммит/роллбэк в зависимости от результата 3 шага
	  Пессимистическая блокировка - блокирующий метод, заключающийся в том что база данных эксклюзивно блокируется на время выполнения транзакции. Ждёт в очереди, пока можно будет изменить ресурс (ПОВТОРИТЬ + ДОПОЛНИТЬ)
	  Есть блокировка при чтении и блокировка при записи 
  <mark style="background: #FFF3A3A6;">Что такое deadlock?(как бороться с deadlock*ом)</mark>
	  _**Deadlock**_ — будущая [компьютерная игра](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0 "Компьютерная игра") в жанре многопользовательского [шутера от третьего лица](https://ru.wikipedia.org/wiki/%D0%A8%D1%83%D1%82%D0%B5%D1%80_%D0%BE%D1%82_%D1%82%D1%80%D0%B5%D1%82%D1%8C%D0%B5%D0%B3%D0%BE_%D0%BB%D0%B8%D1%86%D0%B0 "Шутер от третьего лица"), разрабатываемая и издаваемая компанией [Valve](https://ru.wikipedia.org/wiki/Valve "Valve"). Сочетает в себе элементы жанров [геройского шутера](https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%80%D0%BE%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%88%D1%83%D1%82%D0%B5%D1%80 "Геройский шутер"). Шутка.
	  Deadlock - взаимная блокировка, состояние, когда несколько процессов ожидают ресурс, который занят друг другом
	  Как бороться:
	  1) Правильное проектирование (Короткие транзакции, не требовать взаимодействия от пользователя на период транзакции, консистентные блокировки, таймауты блокировок)
	  2) Оптимистичная блокировка
	  3) Использование изоляции
	  4) Использование индексов
	  5) Мониторинг и предупреждение взаимных блокировок
 <mark style="background: #FFF3A3A6;">Что такое EXPLAIN/ANALYSE?(команды)</mark>
 Обе команды используются для анализа и оптимизации запросов,
 EXPLAIN:
	 Выводит план выполнения запроса: как БД будет выполнять запрос, используемые индексы, методы соединения, порядок выполнения операций
ANALYZE:
	Обновление статистики таблиц и индексов (информация о количестве строк, распределение значений в каждом столбце). Важно для планировщика запросов, который использует их для оценки селективности различных условий в запросах
EXPLAIN ANALYZE:
	Команда EXPLAIN ANALYZE сочетает функциональность EXPLAIN и ANALYZE. Она не только показывает план выполнения запроса, но и фактически выполняет запрос, собирая статистику о времени выполнения и других метриках.
 